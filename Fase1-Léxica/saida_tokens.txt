HASHTAG_INCLUDE #include
LESS_THAN <
ID stdio
DOT .
ID h
GREATER_THAN >
TYPEDEF typedef
STRUCT struct
LBRACE {
INT int
ID x
SEMICOLON ;
INT int
ID y
SEMICOLON ;
RBRACE }
ID ponto_t
SEMICOLON ;
DOUBLE double
ID func
LPAREN (
ID ponto_t
ID v
LBRACKET [
RBRACKET ]
COMMA ,
INT int
ID n
RPAREN )
LBRACE {
IF if
LPAREN (
ID n
LESS_THAN_OR_EQUAL <=
INT_OCTAL 0
RPAREN )
LBRACE {
RETURN return
FLOAT_CONSTANT 1.0
SEMICOLON ;
RBRACE }
ELSE else
IF if
LPAREN (
ID n
EQ ==
INT_DECIMAL 1
RPAREN )
LBRACE {
RETURN return
FLOAT_CONSTANT 1.01
PLUS +
ID v
LBRACKET [
INT_OCTAL 0
RBRACKET ]
DOT .
ID x
DIV /
FLOAT_CONSTANT 1.e2
PLUS +
ID v
LBRACKET [
INT_OCTAL 0
RBRACKET ]
DOT .
ID y
DIV /
FLOAT_CONSTANT 0.1e-2
SEMICOLON ;
RBRACE }
DOUBLE double
ID res
ASSIGN =
FLOAT_CONSTANT .25e-13
SEMICOLON ;
FOR for
LPAREN (
INT int
ID i
ASSIGN =
ID n
MINUS -
INT_DECIMAL 1
SEMICOLON ;
ID i
GREATER_THAN_OR_EQUAL >=
INT_OCTAL 0
LOGICAL_AND &&
ID v
LBRACKET [
ID i
RBRACKET ]
DOT .
ID x
GREATER_THAN >
INT_OCTAL 0
SEMICOLON ;
DECREMENT --
ID i
RPAREN )
LBRACE {
DOUBLE double
ID temp
ASSIGN =
ID v
LBRACKET [
ID i
RBRACKET ]
DOT .
ID y
MULT *
ID v
LBRACKET [
ID i
RBRACKET ]
DOT .
ID x
MOD %
INT_DECIMAL 123
SEMICOLON ;
IF if
LPAREN (
ID temp
LESS_THAN <
FLOAT_CONSTANT 0.0
RPAREN )
LBRACE {
ID res
MINUS_ASSIGN -=
ID res
MULT *
FLOAT_CONSTANT 2.e-2
PLUS +
ID func
LPAREN (
ID v
COMMA ,
ID n
MINUS -
INT_DECIMAL 1
RPAREN )
MULT *
ID temp
SEMICOLON ;
RBRACE }
ELSE else
LBRACE {
ID res
PLUS_ASSIGN +=
ID res
MULT *
FLOAT_CONSTANT .3e3
PLUS +
ID func
LPAREN (
ID v
COMMA ,
ID n
MINUS -
INT_DECIMAL 2
RPAREN )
MULT *
ID temp
SEMICOLON ;
ID printf
LPAREN (
STRING_LITERAL "Estranho, ne?\n"
RPAREN )
SEMICOLON ;
RBRACE }
RBRACE }
RETURN return
ID res
SEMICOLON ;
RBRACE }
